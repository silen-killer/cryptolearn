+++
title = "Coppersmith's Method"
weight = 5
+++

Coppersmith's attack is a technique used in cryptography to factorize the private key of a public key encryption system. It is applied specifically to RSA encryption, which is one of the most widely used public key encryption systems.

In RSA encryption, the private key is generated by multiplying two prime numbers. Coppersmith's attack exploits the low-order bits of the private key to find the prime factors. The technique is based on the observation that the modular reduction operation used in RSA encryption does not affect the lower order bits of the private key. This makes it possible to find the prime factors by solving a system of linear equations.

The Coppersmith's attack is efficient when the size of the private key is small, and the number of bits required to represent the prime factors is small compared to the total size of the private key. 

{{<code>}}
import logging
import os
import sys
from math import *
from sage.all import *

def factorize_p(N, partial_p, beta=0.5, epsilon=0.125, m=None, t=None):
    """
    Recover the prime factors from a modulus using Coppersmith's method and bits of one prime factor p are known.
    More information: May A., "New RSA Vulnerabilities Using Lattice Reduction Methods" (Section 3.2)
    More information: Herrmann M., May A., "Solving Linear Equations Modulo Divisors: On Factoring Given Any Bits" (Section 3 and 4)
    :param N: the modulus
    :param partial_p: the partial prime factor p (PartialInteger)
    :param beta: the parameter beta (default: 0.5)
    :param epsilon: the parameter epsilon (default: 0.125)
    :param m: the number of normal shifts to use (default: automatically computed using beta and epsilon)
    :param t: the number of additional shifts to use (default: automatically computed using beta and epsilon)
    :return: a tuple containing the prime factors, or None if the factors could not be found
    """
    n = partial_p.unknowns
    assert n > 0
    if n == 1:
        m = ceil(max(beta ** 2 / epsilon, 7 * beta)) if m is None else m
        t = int((1 / beta - 1) * m) if t is None else t
        small_roots = howgrave_graham.modular_univariate
    elif n == 2:
        m = ceil((3 * beta * (1 + sqrt(1 - beta))) / epsilon) if m is None else m
        t = int((1 - sqrt(1 - beta)) * m) if t is None else t
        small_roots = herrmann_may_multivariate.modular_multivariate
    else:
        m = ceil((n * (1 / pi * (1 - beta) ** (-0.278465) - beta * log(1 - beta))) / epsilon) if m is None else m
        t = int((1 - (1 - beta) ** (1 / n)) * m) if t is None else t
        small_roots = herrmann_may_multivariate.modular_multivariate

    x = Zmod(N)[tuple(f"x{i}" for i in range(n))].gens()
    f = partial_p.sub(x)
    X = partial_p.get_unknown_bounds()
    logging.info(f"Trying m = {m}, t = {t}...")
    for roots in small_roots(f, N, m, t, X):
        p = partial_p.sub(roots)
        if p != 0 and N % p == 0:
            return p, N // p

    return None
{{</code>}}
